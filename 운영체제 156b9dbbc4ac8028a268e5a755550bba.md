# 운영체제

Status: In progress
완독: No

**목차**

# Section1) 운영체제 들어가기

## 운영 체제가 하는 일

1. 프로세스 관리
2. 메모리 관리
3. 하드웨어 관리
4. 파일 시스템 관리

**1940년대** 최초의 컴퓨터 애니악

**1950년대** 싱글 프로그래밍

**1960년대** 멀티 프로그래밍, 다중 사용자, 파일 시스템

## 운영 체제의 구조

### 커널, 인터페이스, GUI, CLI

![image.png](%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/image.png)

- 커널: 사용자는 커널에 직접 접근할 수 없고, 인터페이스를 통해서 접근할 수 있음
- 인터페이스

- GUI(Graphic User Interface) : Windows, 맥OS와 같은 그래픽
    
    ![image.png](%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/image%201.png)
    

- CLI(Command-Line Interface): 유닉스, 리눅스 같은 운영체제가 기본적으로 제공하는 인터페이스로 텍스트를 이용해 커널과 상호작용
    
    ![image.png](%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/image%202.png)
    

### 시스템콜

![image.png](%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/image%203.png)

- 사용자와 애플리케이션은 커널과의 인터페이스로 ***시스템콜을*** 사용
- 시스템콜을 통해서 하드디스크 빈 공간에 데이터를 저장해준다.

### 드라이버

![image.png](%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/image%204.png)

- 하드웨어와 커널의 인터페이스로는 ***드라이버를*** 사용
- 키보드, 마우스 등과 같은 기본적인 것들은 커널에 이미 설치가 되어 있지만 그래픽과 같은 하드웨어는 따로 설치를 해야함

## 컴퓨터 하드웨어와 구조(폰 노이만 구조)

![image.png](%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/image%205.png)

- 초록색 판때기가 메인보드임
- 메인보드는 다른 하드웨어를 연결하는 장치!! → 장치간의 데이터를 전송하는 건 메인보드의 버스가 담당
- 메인보드에 각각의 하드웨어 장치가 존재

### CPU 구조

![image.png](%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/image%206.png)

### 메모리 종류

- RAM: 전력이 끊기면 데이터를 잃기 때문에 프로그램을 실행시킬 때 사용한다.
- ROM: 전력이 끊겨도 데이터를 계속 보관할 수 있지만 데이터를 한번 쓰면 수정이 불가능함 따라서 컴퓨터 부팅과 관련된 BIOS를 저장하는 데에 주로 사용한다.

### PC 를 부팅할 때 일어나는 과정

1. BOIS가 먼저 실행 : 전원, CPU, 메모리, 키보드, 마우스, 하드디스크 등 주요 하드웨어에 이상이 없는지 확인
2. 설치되어 있는 소프트웨어(운영체제)가 여러 개라면 그 중 무엇을 실행할 지 선택하는 화면 출력
3. 선택한 운영체제 실행

## 인터럽트

![image.png](%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/image%207.png)

: 입출력 장치에서 작업 완료를 CPU에게 알리는 비동기적인 신호 전달 방식 

기존 폴링 방식은 CPU가 입출력 명령을 계속해서 확인해줘야 하기 때문에 성능이 좋지 않음

인터럽트 방식은 이러한 단점을 보완한 방식으로 비동기로 업무를 처리할 수 있음(입출력이 들어오기 전까지 CPU는 다른 업무 처리를 할 수 있음)

# Section2) 프로세스와 쓰레드

## 프로그램과 프로세스

### 프로그램(Program)

: 애플리케이션이나 앱이라고도 불리고 윈도우 운영체제에서는 .exe 파일의 모습을 함

### 프로세스(Process)

: 하드디스크(SSD, HDD)에 저장된 프로그램이 메모리(RAM)에 올라갔을 때 실행 중인 프로그램을 프로세스라고 함 (= 실행중인 프로그램)

![image.png](%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/image%208.png)

<aside>
❗

프로세스의 구조

</aside>

1. code 영역:  자신을 실행하는 코드 저장
2. data 영역: 전역 변수와 static 변수 저장
3. stack 영역: 지역 변수와 함수를 호출했을 때 필요한 정보들 저장
4. heap 영역: 프로그래머가 런타임시 할당할 수 있는 메모리 공간

운영체제가 프로세스를 관리한다.

## 멀티프로그래밍과 멀티프로세싱

### 유니 프로그래밍

![image.png](%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/image%209.png)

- 유니 프로그래밍: 메모리에 프로세스 1개
- 메모리에 프로세스 1개이므로 한 번에 한 개의 작업만 가능

### 멀티 프로그래밍

![image.png](%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/image%2010.png)

메모리에 프로세스가 여러 개 존재하며, 하나의 프로그램에서 IO(입출력)작업이 일어날 때 다른 프로그램이 실행되는 것을 ***멀티 프로그래밍***이라고 함

여러 프로그램을 짧게 실행시키면서 동시에 실행시키는 것처럼 보이도록 하는 것을 ***멀티태스킹이라고*** 함

### 멀티 프로세싱

![image.png](%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/image%2011.png)

CPU가 여러 개 있는 것을 ***멀티프로세서***라고 함

→ ***멀티프로세서로 작업을 처리하는 것을 멀티 프로세싱이라고 함***

## PCB(Process Control Block)

운영체제는 프로세스를 관리하고 운영시키는데, 적절한 관리를 위해서 PCB를 만들어 각각의 프로세스를 관리한다.e

![image.png](%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/image%2012.png)

- 프로세스가 만들어지면 운영체제는 해당 프로세스의 정보를 가지고 있는 PCB를 만들고 저장
- PCB는 서로 연결 리스트 구조를 유지한다.
- 만약 프로세스A가 종료되면 프로세스A의 정보를 지닌 PCB는 제거된다.

PCB의 구조

![image.png](%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/image%2013.png)

## 프로세스 상태

오늘 날 운영체제는 동시에 많은 프로세스를 실행한다. 

시분할 시스템을 사용하는 운영체제는 여러 개의 프로세스를 돌아가면서 실행시키는데, 짧은 시간에 여러 프로세스를 번갈아가면서 실행시키기 때문에 사람의 눈으로 봤을 때는 동시에 실행시키는 것처럼 보여진다. (한순간에는 하나의 프로세스만 실행 가능)

### 프로세스 상태

1. 생성 상태
2. 준비 상태
3. 실행 상태
4. 대기 상태
5. 완료 상태

## 컨텍스트 스위칭

### 개념 및 발생원인

![image.png](%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/image%2014.png)

: 컨텍스트 스위칭이 발생하는 이유는 프로세스A를 실행하는 중에 프로세스B를 실행하기 위해서 현재 실행중인 프로세스의 상태를 저장하고 다른 프로세스의 상태 값으로 교체하는 작업이다.

### 스위칭 과정

![image.png](%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/image%2015.png)

스위칭 할 때에는 실행하고자 하는 프로세스의 정보를 지닌 PCB의 레지스터 값을 CPU의 레지스터 값으로 설정하게 된다.

예를 들어, 프로세스A를 실행하고 있을 때에는 CPU의 레지스터에는 프로세스A의 PCB 레지스터 값이 설정되고, 이후 프로세스B를 실행하고자 할 경우에는 프로세스B의 PCB 레지스터 값이 설정된다.

## 프로세스 실행과 종료

컴퓨터 부팅 시 최초의 프로세스를 생성하는데, 이 프로세스를 0번이라는 식별자가 부여되어 0번 프로세스라고 불린다.

0번 프로세스를 복사해서 자식 프로세스를 만들어내고 exec를 통해서 

## 쓰레드

***쓰레드는 프로세스의 (스택을 제외한) 코드, 데이터, 힙 영역을 공유하므로 메모리 절약 가능 !!***

### 이전의 웹 브라우저 생성 방식

프로세스의 수가 많아지면 프로세스의 수만큼 PCB, 코드, 데이터, 스택, 힙 영역도 만들어져야하기 때문에 속도가 느려진다. (아래 이미지 참고)

![image.png](%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/image%2016.png)

예) 웹 브라우저를 실행시키면 하나의 프로세스가 실행된다. 그리고 그 웹 브라우저에서 탭 20개를 생성하면 **프로세스 복사가20번 일어나고**, 20개의 PCB와 코드, 데이터, 스택,힙 영역이 만들어진다. (아래 이미지 참고)

![image.png](%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/image%2017.png)

→ 웹 브라우저의 메모리 차지가 너무 커진다.

이를 해결 하기 위해서 만들어진 것이 쓰레드 !! 

### 메모리 낭비 해결 → 쓰레드

웹 브라우저를 열면 하나의 프로세스가 생성되고, 탭을 추가하면 프로세스가 복사되는 것이 아닌 쓰레드를 하나 더 생성한다.

![image.png](%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/image%2018.png)

***쓰레드는 프로세스의 코드, 데이터, 힙 영역을 공유하므로 메모리 절약 가능 !!***

### 프로세스와 쓰레드의 장단점

|  | 프로세스 | 쓰레드 |
| --- | --- | --- |
| 안정성 | **높음**
: 프로세스는 서로 독립적 → 각각의 프로세스에 문제가 생기더라도 서로 영향을 받지 않음 | **낮음**
: 하나의 프로세스에 여러 쓰레드가 존재하여 프로세스에 이상이 생기면 쓰레드가 모두 죽음 |
| 속도와 자원 | 메모리 차지 큼, 속도 느림 | 오버헤드 작음 |

# Section3) CPU 스케줄링

## CPU 스케줄링 개요

### **컴퓨터 자원**

- 필수장치: CPU, 메모리 → 이번 섹션에서 살펴볼 내용
- 주변장치: HDD, 키보드, 마우스

### 필수장치

프로세스는 CPU를 차지하기 위해서 대기하고 있으며, 운영체제는 프로세스에 CPU를 할당해준다.

이때 사용되는 방식이 시분할 처리 방식이다. 

예를 들어, 프로세스a 에게 1초 동안 CPU를 할당해준 뒤, 다시 프로세스a에게 할당했던 CPU를 뺏어 프로세스b에게 1초 동안 CPU를 할당하고 … 이런식으로 반복하는 것 !!

## 다중큐

![image.png](%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/image%2019.png)

프로세스 상태 중에서 프로세스가 대기하고 있는 준비상태와 대기상태는 큐(Queue)라는 자료구조로 관리된다.

### 큐 (Queue)

: 먼저 들어온 것이 먼저 처리되고, 나중에 들어온 것이 나중에 처리되는 구조(순서대로 처리 되는 구조)

↔ 먼저 들어온 것이 나중에 처리되고, 나중에 들어온 것이 먼저 처리되는 스택과 상반된다.

<aside>
🧑🏻‍💻

준비상태

</aside>

![image.png](%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/image%2020.png)

준비상태의 다중큐에서 적절한 PBC를 꺼내서 실행하게 된다.

<aside>
⌨️

대기상태

</aside>

![image.png](%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/image%2021.png)

I/O 작업 종류에 따라서 분류된 큐에 프로세스의 PCB가 차례대로 들어가게 되고, 프로세스의 상태를 변경할 때는 해당 큐에서 PCB를 다시 꺼내서 실행시킨다.

## 스케줄링 목표

1. 리소스 사용률
2. 오버헤드 최소화
3. 공평성
    - 특별한 상황이 아닌 이상 모든 프로세스에 CPU 할당 시간이 동일하게 부여되는 것이 공평한 것
4. 처리량
    - 같은 시간 내에 많은 처리를 할 수 있도록 하는 것을 목표로 함
5. 대기시간
6. 응답시간
    - 사용자의 요청에 따른 응답시간을 최대한 짧게 줄이는 것

## 스케줄링 종류1) FIFO (First In First Out)

![image.png](%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/image%2022.png)

: 스케줄링 큐에 들어온 순서 대로 CPU를 할당받는 방식 → 먼저 들어온 프로세스가 먼저 끝나야 나중에 들어온 프로세스가 실행될 수 있음

### FIFO 알고리즘의 문제점 💦

![image.png](%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/image%2023.png)

FIFO 알고리즘은 프로세스의 Burst Time에 따라 성능의 차이가 많이 나기 때문에 현대 운영체제(시분할 처리 시스템)에서 잘 쓰이지 않고 일괄 처리 시스템에서 잘 쓰인다.

<aside>
🧑🏻‍💻

***프로세스 성능 계산법***

→ 프로세스의 평균 대기 시간으로 계산 

</aside>

## 스케줄링 종류2) SJF (Shortest Job First)

: Burst Time이 짧은 프로세스를 먼저 실행시키는 방법

### SJF 알고리즘의 문제점 💦

1. 공평성에 어긋난다. Burst Time이 긴 프로세스는 모든 프로세스가 종료된 다음에 실행할 수 있으므로 공평하지 않음
2. 모든 프로세스의 실행 시간을 예측하기가 어려움

✅ 이러한 문제점으로 인해 **SJF 스케줄링은 사용되지 않음** !! 

## 스케줄링 종류3) RR(Round Robin)

RR 알고리즘은 FIFO 알고리즘의 단점을 해결한 알고리즘이다.

### RR 작동 방식

![image.png](%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/image%2024.png)

- 프로세스a에게 2초의 시간을 할당하고 2초가 되면 프로세스b를 실행시키는 방식

### 타임 슬라이스

: 프로세스에게 할당하는 일정 시간은 타임 슬라이스 또는 타임 퀀텀이라고 부른다.

### 동작 예시

![image.png](%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/image%2025.png)

1. p1, p2, p3 프로세스 작업이 동시에 큐에 들어온다.
2. p1이 25s이고, 타임 슬라이스가 10s라면 10초가 지나면 p1 작업이 끊다.
3. 나머지 15s의 작업은 큐의 맨 마지막 순서로 이동된다.
4. p2가 실행되고 p2는 타임 슬라이스보다 실행 시간이 적기 때문에 모두 실행 되고 사라진다.
5. p3가 실행되고 타임 슬라이스와 p3의 실행시간이 동일하기 때문에 모두 실행 되고 사라진다.
6. 첫 번째로 실행됐던 p1의 남은 작업(15s)이 타임 슬라이스 만큼 실행된다.
7. p1의 남은 작업이 큐의 마지막 순서로 이동되고, 남은 5초가 실행되고 사라진다.

### RR 알고리즘의 문제점 💦

1. FIFO 알고리즘과 RR 알고리즘의 평균 대기 시간이 비슷하다면 **RR 알고리즘은 컨텍스트 스위칭이 있기 때문에 컨텍스트 스위칭 시간이 추가되므로** RR 알고리즘이 더 비효율적인 방식이다.
2. 타임 슬라이스 값에 따라서 성능이 크게 달라진다. (타임 슬라이스가 작을수록 성능이 좋아진다.)
    
    ***<타임 슬라이스가 클 경우>***
    
    ![image.png](%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/image%2026.png)
    
    → 위에 이미지를 보면 타임 슬라이스가 클 경우 웹 브라우저가 5초 동작하다가 멈추고, 뮤직 플레이어가 5초 동작하다가 멈추는 식으로 동작이 되므로 타임 슬라이스가 크면 프로그램이 부드럽게 동작하지 않음
    
    ***<타임 슬라이스가 작을 경우>***
    
    ![image.png](%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/image%2027.png)
    
    → 위에 이미지를 보면 타임 슬라이스가 작을 경우 사용자가 느끼기엔 프로세스가 부드럽게 동작하는 것처럼 보이지만 이렇게 되면 컨텍스트 스위칭이 자주 일어나게 되고 프로세스의 처리량보다 컨텍스트 스위칭을 처리하는 양이 훨씬 커져서 성능이 느려진다. (오버헤드가 너무 큼 💦)
    
    Windows : 20ms , Linux : 100ms 임
    

## 스케줄링 종류4) MLFQ (Multi Level Feedback Queue)

: 현대 운영체제에서 가장 일반적으로 사용되는 스케줄링 기법 (RR의 업그레이드 버전)

![image.png](%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/image%2028.png)

- **CPU Bound Process** : CPU 프로세스를 주로 하는 프로세스 ▶️ CPU 사용률과 처리량 중요
- **I/O Bound Process** : 입출력 작업을 주로 하는 프로세스 ▶️ 응답 속도 중요

![image.png](%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/image%2029.png)

🪴 타임 슬라이스를 작게 쪼개면 I/O-bound 프로세스사용률에는 이득이지만 컨텍스트 스위칭으로 인한 CPU-bound 프로세스 사용률은 더 커져 불이익을 얻는다. 반면 타임 슬라이스를 크게 잡는다면  CPU-bound 프로세스 사용률에는 이득이지만 I/O-bound 프로세스 사용률은 대기 시간이 길어지기 때문에 불이익 !!

***이런 문제점을 해결 하기 위해서*** 

MLFQ는 CPU-bound 프로세스 사용률과 I/O-bound 프로세스 사용률이 좋게 나오는 작은 크기의 타임 슬라이스를 유동적으로 선택한다.

![image.png](%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/image%2030.png)

### 운영체제의 CPU-bound 프로세스와 I/O-bound 프로세스 구분법

![image.png](%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/image%2031.png)

▶️ IO-bound 프로세스 : CPU를 사용하는 프로세스가 실행하다가 스스로 CPU를 반납하면 CPU 사용이 적은 프로세스로 간주하여 I/O-bound 프로세스로 구분된다. 

![image.png](%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/image%2032.png)

▶️ CPU-bound 프로세스: 반대로 CPU를 사용하는 프로세스가 타임 슬라이스 크기를 오버해서 강제로 CPU를 뺏기는 상황이면 CPU 사용이 많은 것이니 CPU-bound 프로세스로 구분한다.

![image.png](%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/image%2033.png)

🙋🏻 타임 슬라이스 시간별로 우선순위를 나눈 큐를 여러 개 만들어두고, 우선순위가 높은 순으로 시작해서 프로세스의 작업 시간이 **타임 슬라이스를 오버할 경우 원래 있던 큐보다 우선순위가 낮은 큐로 이동하게 된다**.

# Section4) 프로세스 동기화

## 프로세스 간 통신(IPC)

### 메시지 전달

: 한 프로세스가 다른 프로세스와 메모리를 공유하지 않고 데이터를 전달하는 방식

** 스레드는 같은 메모리를 공유하지만, 프로세스는 독립적인 메모리 공간을 가지며,통신 방식이 이 차이에 따라 달라진다.

### 메시지 전달 방식(4)

- 파이프
    
    ![image.png](%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/image%2034.png)
    
    운영체제가 생성한 통로를 통해 한 프로세스가 다른 프로세스에게 데이터를 전송하거나 읽는 방식
    
    ***특징) 파이프는 스트림 형태의 단방향 통신 ⇒ 송신 프로세스와 수신 프로세스가 동시에 실행되어야 함 !!*** 
    
- 메시지 큐
    
    
    ![image.png](%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/image%2035.png)
    
    ![image.png](%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/image%2036.png)
    
    메시지 큐는 송신 프로세스가 보낸 데이터를 임시 저장소인 큐에 보관했다가 수신 프로세스가 필요할 때 가져가는 방식
    
    ***특징) 두 프로세스가 동시에 실행될 필요가 없으며 양방향 통신이 가능 !!***
    
- 소켓
    
    ![image.png](%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/image%2037.png)
    
    클라이언트 서버 구조로 이루어짐. 같은 컴퓨터뿐만 아니라 다른 네트워크의 프로세스와도 통신 가능
    
    ***특징) 양방향 통신과 비동기 통신이 모두 가능***
    

- 공유 메모리
    
    ![image.png](%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/image%2038.png)
    
    프로세스가 메모리를 공유하여 데이터를 직접 읽고 쓰면서 통신하는 방식
    
    세마포어, 뮤텍스, 모니터가 존재함. 
    
    ***특징) 메모리를 공유할 때 동기화 문제가 발생할 수 있음***
    

## 공유자원과 임계구역

### 공유자원

![image.png](%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/image%2039.png)

: 프로세스 간 통신을 할 때 공통으로 이용하는 변수나 파일

컨텍스트 스위칭으로 시분할 처리를 하기 때문에 어떤 프로세스가 먼저 실행되는지 알 수 없어 프로세스 간 동기화 문제가 발생한다. 

예시) RPG게임에서 캐릭터의 현재 hp=20일 경우, 몬스터에게 공격을 받기 전에 물약을 먹는 상황

![image.png](%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/image%2040.png)

1. 공격받는 코드가 먼저 실행되어 currentHealth = 20 이 저장
2. 컨텍스트 스위칭으로 인해 물약 먹는 코드가 실행
3. 물약 먹는 코드 내부의 currentHealth = 20 저장
4. health = currentHealth + 50이 실행되어 health = 70이 된다.
5. 다시 컨텍스트 스위칭이 일어나서 공격받는 코드 내부 로직이 실행
6. 이전에 currentHealth = 20 이었으므로, health = currentHealth(20) - 10 = 10 이 된다.

⇒ 60이 되는 것이 맞는데 10이 됨.

health 라는 공유자원을 여러 프로세스가 동시에 사용했기 때문에 발생한 문제

### 임계구역

![image.png](%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/image%2041.png)

▶️ 이렇게 여러 프로세스가 동시에 사용하면 안 되는 영역을 정의했는데 이를 “**임계구역**” 이라고 한다.

공유 자원을 서로 사용하기 위해서 경쟁하는 것을 “**경쟁조건**”이라고 한다.

### 임계구역 문제 해결 방법

**상호배제 메커니즘**

1. 임계영역엔 동시에 하나의 프로세스만 접근한다.
2. 여러 요청에도 하나의 프로세스의 접근만 허용한다. 
3. 임계구역에 들어간 프로세스는 빠르게 나와야한다.

## 상호배제 메커니즘1) 세마포어

### 세마포어란?

![image.png](%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/image%2042.png)

: 공유자원을 보관하는 공간을 따로 만들고, 그곳에 공유자원을 저장한다. 그리고 해당 공유 자원을 사용하기 위해서는 열쇠(세마포어)가 필요한데, 운영체제는 먼저 실행 중인 프로세스에게 이 세마포어를 지급하고 프로세스는 공유자원을 다 사용했으면 세마포어를 다시 운영체제에게 돌려준다. 이후 운영체제는 다음 프로세스에게 세마포어를 지급한다.

이렇게 세마포어를 사용하면 동시에 여러 프로세스가 접근할 수 없기 때문에 동기화 문제가 발생하지 않는다.

공유자원이 2개 일 경우 세마포어를 2개로 설정하여 사용하면 됨

### 세마포어의 단점 💦

- wait()함수와 signal() 함수의 순서를 이상하게 호출해서 세마포어를 잘못 사용할 가능성 존재
- 이러한 단점을 보완한 것이 바로 **모니터**

## 상호 배제 메커니즘2) 모니터

### 모니터란?

세마포어의 단점을 보완한 방법으로, 운영체제에서 처리하는 것이 아니라 프로그래밍 언어차원에서 지원하는 방법

![image.png](%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/image%2043.png)

예를들어, 자바에서는 synchronized 키워드가 붙으면 이 키워드가 붙은 함수들은 동시에 여러프로세스에서 실행시킬 수 없음 ⇒ **상호배제**가 이루어짐

## 컴파일과 프로세스

<aside>
🧑🏻‍💻

우리가 작성한 코드가 어떻게 프로세스가 되고 메모리에 할당될까?

</aside>

프로그래밍 언어는 아래로 구분 된다.

| 구분 | 컴파일 언어 | 인터프리터 언어 |
| --- | --- | --- |
| 특징 | 개발자가 코드를 작성하면 컴파일 과정을 거쳐 0과 1로 된 기계어로 실행 파일을 만든다. | 개발자가 작성한 코드를 미리 기계어로 만들지 않고 실행 시 코드를 한줄씩 해석하여 실행하는 언어로, 미리 검사를 하지 않아서 해석할 때 오류가 발생할 수 있다. |
| 속도 | 속도 빠름 | 속도 비교적 느림 |
| 언어 | C, C++, C# | JS, Python, Ruby |

참고로 자바는 혼합형 언어이다. 

프로세스의 구조

![image.png](%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/image%2044.png)

- CODE
    - ret = num1 + num2
    - 실행해야 하는 코드가 들어가는 영역
- DATA
    - 전역 변수나 배열이 들어가는 영여
- STACK
    - 프로세스가 실행될 때 할당되는 메모리
    - 지역 변수와 함수 관련 값
- HEAP
    - 프로세스가 실행될 때 할당되는 메모리
    - 실행 중에 메모리 공간을 할당할 수 있는 유동적인 공간

![image.png](%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/image%2045.png)

1. 전처리기 → 컴파일러 → 어셈블러 → 링커 작업이 모두 완료된 뒤, exe 실행 파일이 만들어진다.
2. exe 실행 파일을 실행시키면 운영체제는 프로세스를 만들어낸다.
    
    ![image.png](%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/image%2046.png)
    
3. exe 파일에 있는 코드 영역과 데이터 영역을 가져와 프로세스의 코드 영역과 데이터 영역에 넣어두고, 빈 상태의 STACK, HEAP 을 할당한다.
4. PCB 를 만들어 프로세스 관리가 가능하도록 한다.

## 메모리 종류

### PC에서 사용되는 메모리 종류

![image.png](%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/image%2047.png)

- 레지스터는 CPU내에 존재하면 가장 빠름, 휘발성 메모리
    - CPU 구분 시 32bit / 64bit로 구분하는데 이는 바로 레지스터의 크기에 따라서 구분되는 것임
    - CPU는 계산을 할 때 메인 메모리(ram)에 있는 값을 레지스터로 가져와 계산을 한다. 그리고 다시 메인메모리에 결과를 저장함

- 캐시는 레지스터와 메인 메모리 사이에 존재
    - 휘발성 메모리
    - 메인 메모리에 있는 값을 레지스터로 옮기려면 시간이 오래걸리므로 필요한 데이터를 미리 캐시에 가져와 저장한다.
    - CPU → 레지스터로 값을 옮길 경우 L1, L2, L3 캐시를 먼저 살핀 다음에 없으면 CPU를 살펴본다.

- 메인 메모리는 실제 운영체제와 다른 프로세스가 올라가는 공간
    - 전원 미공급시 데이터가 지워지는 휘발성 메모리임

## 메모리와 주소

### 메인 메모리 (RAM)

![image.png](%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/image%2048.png)

폰노이만 구조 컴퓨터 

멀티 프로그래밍 환경

![image.png](%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/image%2049.png)

운영체제는 메모리를 관리하기 위해서 1바이트 크기로 구역을 나누고 숫자를 매기는데, 이를 주소라고 한다.

![image.png](%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/image%2050.png)

32bit의 CPU가 다룰 수 있는 메모리 크기: 2^32 = 4GB

64bit의 CPU가 다룰 수 있는 메모리 크기: 2^64 = 1844TB(테라바이트)

64bit가 32bit CPU보다 한번에 처리할 수 있는 양이 많기 때문에 속도가 더 빠르다.

### 절대 주소, 상대 주소

![image.png](%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/image%2051.png)

개발자는 프로그램을 만들 때 프로그램이 실행될 주소를 신경 쓰지 않고 개발한다.

![image.png](%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/image%2052.png)

메모리 관리자가 메모리 주소를 관리하기 때문에 사용자는 100번지 메모리를 가져오라고 하면 알아서 현재 프로그램이 실행되고 있는 0x4000번지에서 시작해서 100번지를 계산하여 4100번지의 데이터를 가져다준다. 

## 메모리 할당방식(2)

<aside>
🧑🏻‍💻

고정 분할 메모리 할당 / 가변 분할 메모리 할당 - 현재에선 거의 사용 X 💦

</aside>

### 고정 분할 메모리 할당

![image.png](%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/image%2053.png)

메모리를 고정된 크기로 분할하여 각 영역에 하나의 프로세스를 할당하는 방식

**단점:** 분할된 메모리 크기에 비해 실행되는 프로세스의 크기가 작을 경우 메모리 공간이 낭비되는 내부 단편화 발생

### 가변 분할 메모리 할당

![image.png](%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/image%2054.png)

프로세스의 크기에 맞게 메모리를 분할하는 방식

**단점:** 프로세스의 크기에 맞춰 메모리를 분할하므로 내부 단편화는 발생하지 않지만, 외부 단편화가 발생할 수 있음. 외부 단편화란, 남은 메모리 공간의 총합은 충분하지만 이들이 연속되지 않아서 프로세스를 실행할 수 없는 상황

연속 메모리 할당은 과거 운영체제에서 사용되던 방식으로, 현재는 임베디드와 같은 특수한 환경에서만 사용 !!

## 가상 메모리

운영체제나 프로세스가 4GB 메모리에서 동작하도록 만들어졌다면 이보다 작은 메모리를 가진 컴퓨터에서는 실행되지 않음

가상메모리는 위와 같은 문제를 해결함. 프로세스는 운영체제 영역이 어디 있는지, 물리 메모리의 크기가 얼마나 큰지 몰라도 된다. 즉, 프로그래머는 물리 메모리의 크기와 프로세스가 메모리의 어느 위치에 올라가는지 신경 쓰지 않고 0번지에서 시작한다고 생각하고 프로그래밍을 진행해도 된다.

![image.png](%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/image%2055.png)

프로세스 입장에서는 물리 메모리에 직접 접근할 일이 없고, 메모리 관리자에게 요청만 하면 된다.

메모리 관리자는 프로세스에 요청이 있다면 그에 맞는 물리 메모리로 연결을 시켜준다. 

### 가상 메모리의 크기

이론 ⇒ 무한대

실제 ⇒ 물리 메모리의 크기와 CPU 비트수로 결정

ex) 32bit CPU인 경우 표현할 수 있는 주소값은 2에 32승으로 대략 4GB 정도가 되며, 가상 메모리의 크기도 동일하게 4GB이다.

<aside>
🧑🏻‍💻

그럼 만약 32bit CPU에 4GB를 차지하는 프로세스 5개와 운영체제를 실행시킨다면? 

</aside>

![image.png](%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/image%2056.png)

운영체제를 제외하더라도 20GB가 필요한데, 4GB로는 턱없이 부족한 상황

**해결** 🍎

가상 메모리 크기에 비해 실행해야 하는 프로세스의 크기가 큰 경우 가상 메모리 시스템은 물리 메모리 내용의 일부를 하드디스크에 있는 스왑 영역으로 옮기고, 처리가 필요할 때 물리 메모리로 가지고 와서 처리하기 때문에 운영체제와 프로세스 5개를 모두 실행시킬 수 있음

![image.png](%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/image%2057.png)